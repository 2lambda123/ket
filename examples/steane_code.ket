from ket.lib import within, measure_free

class steane_code (quant):
    g1 = [I, I, I, X, X, X, X]
    g2 = [I, X, X, I, I, X, X]
    g3 = [X, I, X, I, X, I, X]

    g4 = [I, I, I, Z, Z, Z, Z]
    g5 = [I, Z, Z, I, I, Z, Z]
    g6 = [Z, I, Z, I, Z, I, Z]

    def __init__(self):
        super().__init__(7)
        self.correct(z)

    def project(self, g):
        def inner(aux):
            with control(aux):
                for gi, q in zip(g, self):
                    gi(q)
                    
        with quant(1) as aux:
            within(lambda : h(aux),
                   lambda : inner(aux))
            return measure_free(aux)
       
    def correct(self, error):
        if error != x and error != z:
            raise ValueError("arg 'error' must be 'x' or 'z'")
        
        if error == z:
            g = [self.g1, self.g2, self.g3]
        else:
            g = [self.g4, self.g5, self.g6]

        index = future(-1)
        for g, c in zip(g, [1, 2, 4]):
            index.set(index + self.project(g)*c)

        if index == 0:
            error(self[3])
        if index == 1:
            error(self[1])
        if index == 2:
            error(self[5])
        if index == 3:
            error(self[0])
        if index == 4:
            error(self[4])
        if index == 5:
            error(self[2])
        if index == 6:
            error(self[6])

if __name__ == '__main__': 
    code = steane_code()   
    y(code[3])
    code.correct(x)
    code.correct(z)
    print(dump(code).show('i7'))


