from math import sqrt, pi
from typing import Callable
from os import environ
from qclabs import qubox_ufsc

qubox_ufsc.set_token('eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJRQ0xhYnMgU2VydmVyIChRQ0xhYnMpIiwic3ViIjoiUUNMYWJzIFNlcnZlciBVU0VSIHRva2VuIiwiYXVkIjoidXNlciIsImV4cCI6MTY0NDk3MzI2NywibmJmIjoxNjQ0MzY4NDY3LCJpYXQiOjE2NDQzNjg0NjcsIm5hbWUiOiJFdmFuZHJvIENoYWdhcyIsImVtYWlsIjoiZXYuY3JyOTdAZ21haWwuY29tIn0.TjQ25dxYKLzf4x3ZOjkM1JfL2s8sdTeEesFBYwpccBg')
qubox_ufsc.set_backend('pbw')

def oracle(x : quant , y : quant):
    """f(x) = 1 if x == 3 else 0

    U|x⟩|y⟩ = |x⟩|f(x) ⊕ y⟩
    """
    with control(x, on_state=3):
        X(y)

def grover(size : int, oracle : Callable, outcomes : int = 1) -> int:
    """Grover's search algorithm"""

    s = quant(size)
    aux = X(quant())

    H(s)
    H(aux)

    steps = int((pi/4)*sqrt(2**size/outcomes))
    for _ in range(steps):
        oracle(s, aux)
        with around([H, X], s):
            with control(s[1:]):
                Z(s[0])

    return measure(s).value
    
if __name__ == '__main__':
    from ket.libket import process_top
    size = 12
    print(size+1, 'Qubits used')

    ps = process_top()
    #ps.timeout(2)
    result = grover(size, oracle)
    print('Exprexted result = 3, measured:', result)
    print(f'Execution time = {ps.exec_time:.2f}s')

