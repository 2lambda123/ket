from ket.lib import qft
from ket.plugins import pown
from math import log2, gcd
from random import randint

def pow_ab_of(N):
    """Return a, b for N = a**b"""
    if N == 1:
        return 1, 2
    
    L = N.bit_length()

    y = int(log2(N))
    
    for b in range(2, L+1):
        x = y/b

        u1 = int(2**x)
        u2 = u1+1

        if u1**b == N:
            return u1, b
        elif u2**b == N:
            return u2, b

    return N, 1

def order_find(x, N):
    """Return r for x**r % N = 1"""

    L = N.bit_length()
    t = 2*L+1

    def __order_find(x, N):

        reg1 = quant(t)
        h(reg1)

        pown(x, reg1, N)
        
        adj(qft, reg1)

        return measure(reg1).get()


    rs = __order_find(x, N)
    for _ in range(2):
        rs = gcd(rs, __order_find(x, N))

    try:
        r = 2**t//rs
    except ZeroDivisionError:
        raise ZeroDivisionError('All measurements returned 0. Try again!!!')   
    
    return r

def factors(N):
    """Shor's factorization algorithm"""

    # 1. If N is even, return the factor 2.
    if N % 2 == 0:
        return 2, N//2, 'EVEN'
    
    # 2. Determine whether N = a**b for integers a ≥ 1 and b ≥ 2, 
    # and if so return the factor a.
    a, _ = pow_ab_of(N)
    if a != N:
        return a, N//a, 'POWER'

    # 3. Randomly choose x in the range 1 to N −1. 
    # If gcd(x, N ) > 1 then return the factor gcd(x, N).
    x = randint(2, N-1)

    gcd_x_N = gcd(x, N)
    if gcd_x_N > 1:
        return gcd_x_N, N//gcd_x_N, 'LUCK'
        
    # 4. Use the order-finding subroutine to find the order r of x modulo N.
    r = order_find(x, N)

    # 5. If r is even and x**(r/2) = − 1(mod N ) then compute gcd(x**(r/2) − 1, N )
    # and gcd(x**(r/2) + 1, N ), and test to see if one of these is a non-trivial
    # factor, returning that factor if so. Otherwise, the algorithm fails.
    if r % 2 == 0 and pow(x, r//2) != -1 % N:
        p = gcd(x**(r//2)-1, N)
        Np = N//p
        if p != 1 and Np != 1 and p*Np == N:
            return p, Np, 'QUANTUM'

        q = gcd(x**(r//2)+1, N)
        Nq = N//q
        if q != 1 and Nq != 1 and q*Nq == N:
            return q, Nq, 'QUANTUM'

        raise RuntimeError('Algorithm fails')

if __name__ == '__main__':
    #N = 15  # 13 qubits
    #N = 21  # 16 qubits
    #N = 55  # 19 qubits
    #N = 119 # 22 qubits
    N = 247 # 25 qubits
    
    try:
        print('N =', N, ': bit length =', N.bit_length(), 'Bits,',
               N.bit_length()*3+1, 'Qubits needed')
        p, q, method = factors(N)
        print('Method =', method)
        print(p, 'x', q, '=', p*q)

    except RuntimeError as e:
        print(e)
    except ZeroDivisionError as e:
        print(e)
